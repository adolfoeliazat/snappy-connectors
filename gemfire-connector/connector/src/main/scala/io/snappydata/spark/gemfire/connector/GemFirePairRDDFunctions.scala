/*
 * Copyright (c) 2016 SnappyData, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you
 * may not use this file except in compliance with the License. You
 * may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * permissions and limitations under the License. See accompanying
 * LICENSE file.
 */
package io.snappydata.spark.gemfire.connector

import io.snappydata.spark.gemfire.connector.internal.rdd.{GemFireJoinRDD, GemFireOuterJoinRDD, GemFirePairRDDWriter}
import io.snappydata.spark.gemfire.connector.internal.DefaultGemFireConnectionManager

import org.apache.spark.Logging
import org.apache.spark.api.java.function.Function
import org.apache.spark.rdd.RDD
import org.apache.spark.sql.collection.Utils
import org.apache.spark.sql.types.StructType
import org.apache.spark.sql.{DataFrame, Row}

/**
  * Extra gemFire functions on RDDs of (key, value) pairs through an implicit conversion.
  * Import `org.apache.geode.spark.connector._` at the top of your program to
  * use these functions.
  */
class GemFirePairRDDFunctions[K, V](val rdd: RDD[(K, V)]) extends Serializable with Logging {

  /**
    * Save the RDD of pairs to GemFire key-value store without any conversion
    *
    * @param regionPath the full path of region that the RDD is stored
    * @param opConf     the optional parameters for this operation
    */
  def saveToGemFire(
      regionPath: String,
      opConf: Map[String, String] = Map.empty): Unit = {
    DefaultGemFireConnectionManager.getConnection.validateRegion[K, V](regionPath)
    if (log.isDebugEnabled)
      logDebug(s"""Save RDD id=${rdd.id} to region $regionPath, partitions:\n  ${getRddPartitionsInfo(rdd)}""")
    else
      logInfo(s"""Save RDD id=${rdd.id} to region $regionPath""")
    val writer = new GemFirePairRDDWriter[K, V](regionPath, opConf)
    rdd.sparkContext.runJob(rdd, writer.write _)
  }

  /**
    * Return an RDD containing all pairs of elements with matching keys in `this`
    * RDD and the GemFire `Region[K, V2]`. Each pair of elements will be returned
    * as a ((k, v), v2) tuple, where (k, v) is in `this` RDD and (k, v2) is in the
    * GemFire region.
    *
    * @param regionPath the region path of the GemFire region
    * @tparam K2 the key type of the GemFire region
    * @tparam V2 the value type of the GemFire region
    * @return RDD[T, V]
    */
  def joinGemFireRegion[K2 <: K, V2](
      regionPath: String): GemFireJoinRDD[(K, V), K, V2] = {
    new GemFireJoinRDD[(K, V), K, V2](rdd, null, regionPath)
  }

  /**
    * Return an RDD containing all pairs of elements with matching keys in `this` RDD
    * and the GemFire `Region[K2, V2]`. The join key from RDD element is generated by
    * `func(K, V) => K2`, and the key from the GemFire region is jus the key of the
    * key/value pair.
    *
    * Each pair of elements of result RDD will be returned as a ((k, v), v2) tuple,
    * where (k, v) is in `this` RDD and (k2, v2) is in the GemFire region.
    *
    * @param regionPath the region path of the GemFire region
    * @param func       the function that generates region key from RDD element (K, V)
    * @tparam K2 the key type of the GemFire region
    * @tparam V2 the value type of the GemFire region
    * @return RDD[(K, V), V2]
    */
  def joinGemFireRegion[K2, V2](
      regionPath: String, func: ((K, V)) => K2): GemFireJoinRDD[(K, V), K2, V2] =
  new GemFireJoinRDD[(K, V), K2, V2](rdd, func, regionPath)

  /**
    * Perform a left outer join of `this` RDD and the GemFire `Region[K, V2]`.
    * For each element (k, v) in `this` RDD, the resulting RDD will either contain
    * all pairs ((k, v), Some(v2)) for v2 in the GemFire region, or the pair
    * ((k, v), None)) if no element in the GemFire region have key k.
    *
    * @param regionPath the region path of the GemFire region
    * @tparam K2 the key type of the GemFire region
    * @tparam V2 the value type of the GemFire region
    * @return RDD[ (K, V), Option[V] ]
    */
  def outerJoinGemFireRegion[K2 <: K, V2](
      regionPath: String): GemFireOuterJoinRDD[(K, V), K, V2] = {
    new GemFireOuterJoinRDD[(K, V), K, V2](rdd, null, regionPath)
  }

  /**
    * Perform a left outer join of `this` RDD and the GemFire `Region[K2, V2]`.
    * The join key from RDD element is generated by `func(K, V) => K2`, and the
    * key from region is jus the key of the key/value pair.
    *
    * For each element (k, v) in `this` RDD, the resulting RDD will either contain
    * all pairs ((k, v), Some(v2)) for v2 in the GemFire region, or the pair
    * ((k, v), None)) if no element in the GemFire region have key `func(k, v)`.
    *
    * @param regionPath the region path of the GemFire region
    * @param func       the function that generates region key from RDD element (K, V)
    * @tparam K2 the key type of the GemFire region
    * @tparam V2 the value type of the GemFire region
    * @return RDD[ (K, V), Option[V] ]
    */
  def outerJoinGemFireRegion[K2, V2](
      regionPath: String, func: ((K, V)) => K2): GemFireOuterJoinRDD[(K, V), K2, V2] = {
    new GemFireOuterJoinRDD[(K, V), K2, V2](rdd, func, regionPath)
  }

  /** This version of joinGemFireRegion(...) is just for Java API. */
  private[connector] def joinGemFireRegion[K2, V2](
      regionPath: String, func: Function[(K, V), K2]): GemFireJoinRDD[(K, V), K2, V2] = {
    new GemFireJoinRDD[(K, V), K2, V2](rdd, func.call, regionPath)
  }

  /** This version of outerJoinGemFireRegion(...) is just for Java API. */
  private[connector] def outerJoinGemFireRegion[K2, V2](
      regionPath: String, func: Function[(K, V), K2]): GemFireOuterJoinRDD[(K, V), K2, V2] = {
    new GemFireOuterJoinRDD[(K, V), K2, V2](rdd, func.call, regionPath)
  }


}

class GemFireDataFrameFunctions(val df: DataFrame) extends Serializable with Logging {

  /**
    * Save the RDD of pairs to GemFire key-value store without any conversion
    *
    * @param regionPath the full path of region that the RDD is stored
    * @param opConf     the optional parameters for this operation
    */
  def saveToGemFire[K](
      regionPath: String,
      keyExtractor: Row => K,
      opConf: Map[String, String] = Map.empty): Unit = {
    DefaultGemFireConnectionManager.getConnection.validateRegion[K, Row](regionPath)
    if(df.schema.exists(f => {
      f.dataType match {
        case _: StructType => true
        case _ => false
      }
    })) {
      throw Utils.analysisException("Saving Row object in GemFire is not " +
          "implemented for nested struct type ")
    }
    val pairRDD = df.rdd.map(row => (keyExtractor(row), row.toSeq.toArray))
    val writer = new GemFirePairRDDWriter[K, Array[Any]](regionPath, opConf)
    pairRDD.sparkContext.runJob(pairRDD, writer.write _)
  }
}